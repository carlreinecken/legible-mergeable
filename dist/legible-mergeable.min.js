(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global["legible-mergeable"]=factory())})(this,(function(){"use strict";function hasKey(object,key){return Object.prototype.hasOwnProperty.call(object,key)}function deepCopy(value){return JSON.parse(JSON.stringify(value))}var util={hasKey:hasKey,deepCopy:deepCopy};const CHANGES_KEY="_changes";function mergeArray(docA,docB){const docs={a:docA.map(item=>item.id),b:docB.map(item=>item.id)};const changes={a:docA.find(item=>util.hasKey(item,CHANGES_KEY))[CHANGES_KEY],b:docB.find(item=>util.hasKey(item,CHANGES_KEY))[CHANGES_KEY]};const resultIds=[];let counter=0;const hasNext=side=>docs[side][0]!=null;const shift=side=>docs[side].shift();const shiftBoth=()=>{shift("a");return shift("b")};const getChange=(side,id)=>changes[side][id]?new Date(changes[side][id]):null;while(hasNext("a")||hasNext("b")){const id={a:docs.a[0],b:docs.b[0]};const change={a:{a:getChange("a",id.a),b:getChange("a",id.b)},b:{a:getChange("b",id.a),b:getChange("b",id.b)}};const win=(side,origin)=>{resultIds.push(shift(side))};if(id.a===id.b&&(change.a.a||new Date).getTime()===(change.b.b||new Date).getTime()){resultIds.push(shiftBoth());continue}if(resultIds.includes(id.a)){shift("a");continue}if(resultIds.includes(id.b)){shift("b");continue}if(change.a.a&&!change.b.a&&!docs.b.includes(id.a)){if(change.b.b&&!change.a.b&&!docs.b.includes(id.b)){if(change.a.a>change.b.b){win("b");continue}else if(change.a.a<change.b.b){win("a");continue}}else{win("a");continue}}if(change.b.b&&!change.a.b&&!docs.a.includes(id.b)){if(change.a.a&&!change.b.a&&!docs.b.includes(id.a)){if(change.b.b>change.a.a){win("a");continue}else if(change.b.b<change.a.a){win("b");continue}}else{win("b");continue}}if(change.b.a&&change.a.a<change.b.a&&!docs.b.includes(id.a)){shift("a");continue}if(change.a.b&&change.b.b<change.a.b&&!docs.a.includes(id.b)){shift("b");continue}if(change.a.b>change.b.b){if(change.b.a>change.a.a){shiftBoth();continue}win("a");continue}else if(change.a.b<change.b.b){if(change.b.a<change.a.a){shiftBoth();continue}win("b");continue}else if(change.b.a>change.a.a){if(change.a.b>change.b.b){shiftBoth();continue}win("b");continue}else if(change.b.a<change.a.a){if(change.a.b<change.b.b){shiftBoth();continue}win("a");continue}if(counter++>docs.a.length+docs.b.length){break}}const result=resultIds.map(id=>{const entry=docA.find(item=>item.id===id);return entry==null?docB.find(item=>item.id===id):entry});const allIds=docA.concat(docB,Object.keys(changes.a),Object.keys(changes.b)).map(item=>{if(typeof item==="object"&&item.id){return item.id}else if(typeof item==="string"){return item}});const resultChanges=allIds.reduce((obj,id)=>{const blub=getChange("a",id)>getChange("b",id)?changes.a[id]:changes.b[id];if(blub==null){return obj}return{...obj,[id]:new Date(blub)}},{});result.push({[CHANGES_KEY]:resultChanges});return result}function mergeObject(docA,docB){const docResult={content:{},changes:{}};const properties=[...new Set([].concat(Object.keys(docA.content),Object.keys(docA.changes),Object.keys(docB.content),Object.keys(docB.changes)))];for(const prop of properties){const aChangeAt=docA.changes[prop]?new Date(docA.changes[prop]):null;const bChangeAt=docB.changes[prop]?new Date(docB.changes[prop]):null;if(aChangeAt>bChangeAt){if(util.hasKey(docA.content,prop)){docResult.content[prop]=docA.content[prop]}docResult.changes[prop]=docA.changes[prop]}else if(aChangeAt<bChangeAt){if(util.hasKey(docB.content,prop)){docResult.content[prop]=docB.content[prop]}docResult.changes[prop]=docB.changes[prop]}else{if(util.hasKey(docA.content,prop)){docResult.content[prop]=docA.content[prop]}else if(util.hasKey(docB.content,prop)){docResult.content[prop]=docB.content[prop]}if(!util.hasKey(docResult.changes,prop)){if(util.hasKey(docA.changes,prop)){docResult.changes[prop]=docA.changes[prop]}else if(util.hasKey(docB.changes,prop)){docResult.changes[prop]=docB.changes[prop]}}}}return docResult}const TYPES={OBJECT:"OBJECT",ARRAY:"ARRAY"};class legibleMergeable{constructor(type,state,changes){this.type=type;this.state=state;this.changes=changes}static create(object){if(Array.isArray(object)){let changes={};const state=util.deepCopy(object);const changesIndex=state.findIndex(item=>util.hasKey(item,CHANGES_KEY));if(changesIndex>0){changes=state.splice(changesIndex,1)[0][CHANGES_KEY]}return new this(TYPES.ARRAY,state,changes)}else if(typeof object==="object"){let changes={};const state=util.deepCopy(object);if(util.hasKey(state,CHANGES_KEY)){changes=state[CHANGES_KEY];delete state[CHANGES_KEY]}return new this(TYPES.OBJECT,state,changes)}}isObject(){return this.type===TYPES.OBJECT}isArray(){return this.type===TYPES.ARRAY}has(key){return util.hasKey(this.state,key)}get(key){if(this.has(key)){return this.state[key]}}set(key,value,date){if(this.isArray()){throw new Error("set() was used on a mergeable array, set() is only for objects")}this.state[key]=value;this.changes[key]=date||new Date}delete(key,date){delete this.state[key];this.changes[key]=date||new Date}add(){}replace(){}move(){}size(){}toBase(){return util.deepCopy(this.state)}dump(){if(this.isObject()){return{...this.state,[CHANGES_KEY]:this.changes}}if(this.isArray()){return[...this.state,{[CHANGES_KEY]:this.changes}]}}toString(){return JSON.stringify(this.dump())}static merge(stateA,stateB){if(stateA.isArray()&&stateB.isArray()){return mergeArray(stateA.dump(),stateB.dump())}else if(stateA.isObject()&&stateB.isObject()){return mergeObject(stateA.dump(),stateB.dump())}}merge(stateB){if(!(stateB instanceof legibleMergeable)){return}return legibleMergeable.merge(this.dump(),stateB.dump())}}return legibleMergeable}));
