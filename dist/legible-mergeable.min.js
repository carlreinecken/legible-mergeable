(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.legibleMergeable=factory())})(this,(function(){"use strict";const MERGEABLE_MARKER="^lm";const POSITION_KEY=MERGEABLE_MARKER+".position";const MERGE_RESULT_IS_IDENTICAL="MERGE_RESULT_IS_IDENTICAL";const WRONG_TYPE_GIVEN_EXPECTED_OBJECT="WRONG_TYPE_GIVEN_EXPECTED_OBJECT";const POSITION={DEFAULT_MIN:0,DEFAULT_MAX:parseInt("zzzzzz",36),IDENTIFIER_SEPARATOR:" ",INNER_RANGE_SIZE:1e7};var constants=Object.freeze({__proto__:null,MERGEABLE_MARKER:MERGEABLE_MARKER,POSITION_KEY:POSITION_KEY,MERGE_RESULT_IS_IDENTICAL:MERGE_RESULT_IS_IDENTICAL,WRONG_TYPE_GIVEN_EXPECTED_OBJECT:WRONG_TYPE_GIVEN_EXPECTED_OBJECT,POSITION:POSITION});function hasKey(object,key){return Object.prototype.hasOwnProperty.call(object,key)}function isObject(object){return Object.prototype.toString.call(object)==="[object Object]"}function deepCopy(value){return JSON.parse(JSON.stringify(value))}function uniquenizeArray(array){return[...new Set(array)]}function hasMarker(property){return hasKey(property,MERGEABLE_MARKER)&&isObject(property[MERGEABLE_MARKER])}function transformMergeable(dump,transformFn){const result={};if(!isObject(dump)){dump={}}for(const key in dump){if(!hasKey(dump,key)){continue}const property=dump[key];if(!isObject(property)){result[key]=property}else if(key===MERGEABLE_MARKER){continue}else if(hasMarker(property)){result[key]=transformFn?transformFn(property):transformMergeable(property)}else{result[key]=deepCopy(property)}}return result}function renew(mergeable,keys,options){options=options||{};touch(mergeable);keys=Array.isArray(keys)?keys:[keys];for(const key of keys){mergeable[MERGEABLE_MARKER][key]=options.date||(new Date).toISOString()}}function touch(mergeable){if(!isObject(mergeable)){throw new TypeError(WRONG_TYPE_GIVEN_EXPECTED_OBJECT)}if(!hasKey(mergeable,MERGEABLE_MARKER)){mergeable[MERGEABLE_MARKER]={}}return mergeable}function set(mergeable,key,value,options){mergeable[key]=value;renew(mergeable,key,options)}function drop(mergeable,key,options){delete mergeable[key];renew(mergeable,key,options)}function base(mergeable){return transformMergeable(mergeable)}function clone(mergeable){const transformed=transformMergeable(mergeable,property=>clone(property));if(isObject(mergeable)&&hasKey(mergeable,MERGEABLE_MARKER)){transformed[MERGEABLE_MARKER]={...mergeable[MERGEABLE_MARKER]}}return transformed}function modifications(mergeable,modifications){if(!isObject(mergeable)){return{}}if(isObject(modifications)){mergeable[MERGEABLE_MARKER]=modifications}if(hasKey(mergeable,MERGEABLE_MARKER)){return mergeable[MERGEABLE_MARKER]}return{}}var apiFunctions=Object.freeze({__proto__:null,renew:renew,touch:touch,set:set,drop:drop,base:base,clone:clone,modifications:modifications});function isPropertyMergeable(property){return isObject(property)&&hasMarker(property)}function stateWithoutMarker(state){const result={...state};delete result[MERGEABLE_MARKER];return result}function setModification(resultReference,mods,key){resultReference[MERGEABLE_MARKER][key]=mods[key]}function setProperty(resultReference,state,key){if(hasKey(state,key)){if(isPropertyMergeable(state[key])){resultReference[key]=clone(state[key])}else{resultReference[key]=deepCopy(state[key])}}}function mergeFunction(docA,docB){let isIdentical=true;const input={a:{state:stateWithoutMarker(docA),mods:docA[MERGEABLE_MARKER]||{}},b:{state:stateWithoutMarker(docB),mods:docB[MERGEABLE_MARKER]||{}}};const result={[MERGEABLE_MARKER]:{}};const properties=uniquenizeArray([].concat(Object.keys(input.a.state),Object.keys(input.a.mods),Object.keys(input.b.state),Object.keys(input.b.mods)));for(const key of properties){const aChangedAt=input.a.mods[key]?new Date(input.a.mods[key]):null;const bChangedAt=input.b.mods[key]?new Date(input.b.mods[key]):null;if(aChangedAt>bChangedAt){setProperty(result,input.a.state,key);setModification(result,input.a.mods,key);isIdentical=false;continue}if(aChangedAt<bChangedAt){setProperty(result,input.b.state,key);setModification(result,input.b.mods,key);isIdentical=false;continue}if(hasKey(input.a.mods,key)){setModification(result,input.a.mods,key)}if(isPropertyMergeable(input.a.state[key])&&isPropertyMergeable(input.b.state[key])){const property=mergeFunction(input.a.state[key],input.b.state[key]);result[key]=property.result;isIdentical=isIdentical&&property.isIdentical;continue}if(hasKey(input.a.state,key)){result[key]=deepCopy(input.a.state[key])}}return{result:result,isIdentical:isIdentical}}function createProxy(dump,options){const result=transformMergeable(dump,item=>createProxy(item,options));result[MERGEABLE_MARKER]={...dump[MERGEABLE_MARKER]}||{};return getProxy(result,options)}function getProxy(mergeable,options){return new Proxy(mergeable,{set(target,key,value,receiver){if(value&&isObject(value)&&hasMarker(value)){value=createProxy(value,options)}renew(target,key,options);return Reflect.set(target,key,value,receiver)},deleteProperty(target,key){renew(target,key,options);return Reflect.deleteProperty(target,key)},getOwnPropertyDescriptor(target,key){if(key===MERGEABLE_MARKER){return{enumerable:false,configurable:true,writable:true}}return Reflect.getOwnPropertyDescriptor(target,key)}})}function generate(prevPos,nextPos){prevPos=prevPos||[];nextPos=nextPos||[];if(prevPos.length>0&&nextPos.length>0&&compare(prevPos,nextPos)===0){throw new Error("Could not generate new position, no space available.")}const prevPosHead=prevPos.length>0?prevPos[0]:POSITION.DEFAULT_MIN;const nextPosHead=nextPos.length>0?nextPos[0]:POSITION.DEFAULT_MAX;const diff=Math.abs(prevPosHead-nextPosHead);let newPos=[prevPosHead];if(diff<POSITION.INNER_RANGE_SIZE*2){newPos=newPos.concat(generate(prevPos.slice(1),nextPos.slice(1)))}else{let min=prevPosHead+POSITION.INNER_RANGE_SIZE*.5;let max=prevPosHead+POSITION.INNER_RANGE_SIZE*1.5;if(min>max){const temp=min;min=max;max=temp}newPos[0]=Math.floor(Math.random()*(max-(min+1)))+min+1}return newPos}function compare(a,b){const next=x=>x.length>1?x.slice(1):[POSITION.DEFAULT_MIN];const diff=(a[0]||0)-(b[0]||0);if(diff===0&&(a.length>1||b.length>1)){return compare(next(a),next(b))}else if(diff>0){return 1}else if(diff<0){return-1}return 0}function next(positions,positionMark){let result=[POSITION.DEFAULT_MAX];for(const cursor of positions){const cursorIsBiggerThanMark=compare(cursor,positionMark)===1;const cursorIsLessThanResult=compare(cursor,result)===-1;if(cursorIsBiggerThanMark&&cursorIsLessThanResult){result=cursor}}return result}function fromArray(array,indexKey,options){options=options||{};const dropIndexKey=options.dropIndexKey===true;const mergeable={};for(const element of array){if(!isObject(element)){continue}const key=element[indexKey];mergeable[key]=element;if(dropIndexKey){delete mergeable[key][indexKey]}}return mergeable}function toArray(mergeable,options){options=options||{};const indexKey=options.indexKey;const positionKey=options.positionKey||POSITION_KEY;const array=[];for(const key in mergeable){if(key===MERGEABLE_MARKER||!hasKey(mergeable,key)){continue}const element=mergeable[key];if(indexKey){element[indexKey]=key}array.push(element)}return sort(positionKey,array)}function size(mergeable){let counter=0;for(const key in mergeable){if(hasKey(mergeable,key)&&key!==MERGEABLE_MARKER){counter++}}return counter}function filter(mergeable,callback){const result=[];for(const key in mergeable){if(!hasKey(mergeable,key)||key===MERGEABLE_MARKER){continue}const modification=modifications(mergeable)[key];if(!callback||callback(mergeable[key],key,modification)){result.push(mergeable[key])}}return result}function map(mergeable,callback){const result=[];for(const key in mergeable){if(!hasKey(mergeable,key)||key===MERGEABLE_MARKER){continue}const modification=modifications(mergeable)[key];const evaluation=callback(mergeable[key],key,modification);result.push(evaluation)}return result}function reduce(mergeable,callback,accumulator){for(const key in mergeable){if(!hasKey(mergeable,key)||key===MERGEABLE_MARKER){continue}if(accumulator==null){accumulator=mergeable[key]}const modification=modifications(mergeable)[key];accumulator=callback(accumulator,mergeable[key],key,modification)}return accumulator}function first(mergeable,options){options=options||{};const positionKey=options.positionKey||POSITION_KEY;return reduce(mergeable,(accumulator,element)=>{if(element[positionKey]==null){return accumulator}const smallerStays=compare(accumulator[positionKey],element[positionKey])===-1;return smallerStays?accumulator:element})}function last(mergeable,options){options=options||{};const positionKey=options.positionKey||POSITION_KEY;return reduce(mergeable,(accumulator,element)=>{if(element[positionKey]==null){return accumulator}const highestStays=compare(accumulator[positionKey],element[positionKey])===1;return highestStays?accumulator:element})}function move(mergeable,key,afterKey,options){options=options||{};const positionKey=options.positionKey||POSITION_KEY;let afterPosition=null;if(afterKey!=null){if(!hasKey(mergeable,afterKey)){throw new Error(`Could not find id ${afterKey} in mergeable.`)}afterPosition=mergeable[afterKey][positionKey]}const currentPosition=mergeable[key][positionKey];const allPositions=getAllPositionsExcept(mergeable,currentPosition,positionKey);const beforePosition=next(allPositions,afterPosition||[]);const position=generate(afterPosition,beforePosition);set(mergeable[key],positionKey,position,options)}function reposition(mergeable,key,options){}function push(mergeable,key,options){options=options||{};const positionKey=options.positionKey||POSITION_KEY;const lastElement=last(mergeable,options);const afterPosition=lastElement.position;const position=generate(afterPosition,null);set(mergeable[key],positionKey,position,options)}function sort(positionKey,array){array.sort((a,b)=>{if(!hasKey(a,positionKey)||!hasKey(b,positionKey)){throw new Error(`Sorting failed. Position key ${positionKey} is missing on element.`)}return compare(a[positionKey],b[positionKey])});return array}function getAllPositionsExcept(mergeable,excludedPosition,positionKey){return map(mergeable,property=>property[positionKey]).filter(position=>{if(position&&!excludedPosition){return true}if(excludedPosition&&position.toString()!==excludedPosition.toString()){return true}return false})}var apiArrayFunctions=Object.freeze({__proto__:null,fromArray:fromArray,toArray:toArray,size:size,filter:filter,map:map,reduce:reduce,first:first,last:last,move:move,reposition:reposition,push:push});var main={...constants,merge(mergeableA,mergeableB){if(!isObject(mergeableA)||!isObject(mergeableB)){throw new TypeError(WRONG_TYPE_GIVEN_EXPECTED_OBJECT)}return mergeFunction(mergeableA,mergeableB).result},mergeOrFail(mergeableA,mergeableB){if(!isObject(mergeableA)||!isObject(mergeableB)){throw new TypeError(WRONG_TYPE_GIVEN_EXPECTED_OBJECT)}const{result:result,isIdentical:isIdentical}=mergeFunction(mergeableA,mergeableB);if(isIdentical){throw new Error(MERGE_RESULT_IS_IDENTICAL)}return result},createProxy:createProxy,...apiFunctions,...apiArrayFunctions};return main}));
