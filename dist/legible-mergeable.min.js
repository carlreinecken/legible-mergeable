(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.legibleMergeable=factory())})(this,(function(){"use strict";const MERGEABLE_MARKER="^lm";function hasKey(object,key){return Object.prototype.hasOwnProperty.call(object,key)}function isObject(object){return Object.prototype.toString.call(object)==="[object Object]"}function deepCopy(value){return JSON.parse(JSON.stringify(value))}function newDate(date){return date||(new Date).toISOString()}function uniquenizeArray(array){return[...new Set(array)]}function hasMarker(property){return hasKey(property,MERGEABLE_MARKER)&&isObject(property[MERGEABLE_MARKER])}function isPropertyMergeable(property){return isObject(property)&&hasMarker(property)}function stateWithoutMarker(state){const result={...state};delete result[MERGEABLE_MARKER];return result}function mergeFunction({a:docA,b:docB}){const input={a:{state:stateWithoutMarker(docA),mods:docA[MERGEABLE_MARKER]},b:{state:stateWithoutMarker(docB),mods:docB[MERGEABLE_MARKER]}};const result={[MERGEABLE_MARKER]:{}};const properties=uniquenizeArray([].concat(Object.keys(input.a.state),Object.keys(input.a.mods),Object.keys(input.b.state),Object.keys(input.b.mods)));for(const prop of properties){const aChangedAt=input.a.mods[prop]?new Date(input.a.mods[prop]):null;const bChangedAt=input.b.mods[prop]?new Date(input.b.mods[prop]):null;if(aChangedAt>bChangedAt){if(hasKey(input.a.state,prop)){result[prop]=deepCopy(input.a.state[prop])}result[MERGEABLE_MARKER][prop]=input.a.mods[prop];continue}if(aChangedAt<bChangedAt){if(hasKey(input.b.state,prop)){result[prop]=deepCopy(input.b.state[prop])}result[MERGEABLE_MARKER][prop]=input.b.mods[prop];continue}if(hasKey(input.a.mods,prop)){result[MERGEABLE_MARKER][prop]=input.a.mods[prop]}if(isPropertyMergeable(input.a.state[prop])&&isPropertyMergeable(input.b.state[prop])){result[prop]=mergeFunction({a:input.a.state[prop],b:input.b.state[prop]});continue}if(hasKey(input.a.state,prop)){result[prop]=deepCopy(input.a.state[prop])}}return result}function createProxy(mergeable,options){return new Proxy(mergeable,{get(target,key){if(hasKey(target,key)&&target[key].__isMergeable===true){return createProxy(target[key],options)}return target[key]},set(target,key,value){target.set(key,value,options);return true},has(target,key){return target.has(key)},deleteProperty(target,key){target.delete(key,options);return true},getOwnPropertyDescriptor(target,key){if(hasKey(target,key)){return Reflect.getOwnPropertyDescriptor(target,key)}return{enumerable:false,configurable:true,writable:true}}})}function transformMergeables(dump,transformFn){return Object.entries(dump).reduce((result,[key,property])=>{if(typeof property!=="object"){result[key]=property}else if(hasMarker(property)){result[key]=transformFn(property)}else{result[key]=deepCopy(property)}return result},{})}function setMergeablePrototype(dump){const result=transformMergeables(dump,item=>setMergeablePrototype(item));result[MERGEABLE_MARKER]=result[MERGEABLE_MARKER]||{};Object.defineProperty(result,MERGEABLE_MARKER,{enumerable:false});return Object.setPrototypeOf(result,mergeablePrototype)}const mergeablePrototype={get __isMergeable(){return true},get _proxy(){return createProxy(this)},has(key){return hasKey(this,key)},get(key,fallback){if(this.has(key)){return this[key]}return fallback},refresh(key,options){options=options||{};this[MERGEABLE_MARKER][key]=newDate(options.date)},set(key,value,options){options=options||{};if(options.mergeable||hasMarker(value));this[key]=value;this[MERGEABLE_MARKER][key]=newDate(options.date);return this[key]},delete(key,options){options=options||{};delete this[key];this[MERGEABLE_MARKER][key]=newDate(options.date)},modify(callback,options){options=options||{};callback(createProxy(this,options));return this},date(key){return this[MERGEABLE_MARKER][key]},size(){return Object.keys(this).length},state(){return{...this}},base(){return transformMergeables(this,property=>property.base())},dump(){return{...transformMergeables(this,property=>property.dump()),[MERGEABLE_MARKER]:this[MERGEABLE_MARKER]}},toString(){return JSON.stringify(this.dump())},toJSON(){return this.dump()},clone(){return setMergeablePrototype(this||{})},merge(docB){if(!isObject(docB)||!hasMarker(docB)){throw TypeError("Only objects with the mergeable marker can be merged")}const result=mergeFunction({a:this,b:docB});for(const key in this){if(!hasKey(this,key)){continue}if(hasKey(result,key)){this[key]=result[key]}else{delete this[key]}}this[MERGEABLE_MARKER]=result[MERGEABLE_MARKER];return this},filter(){return this.state()},map(){}};var legibleMergeable={create(dump){return setMergeablePrototype(dump||{})},merge(docA,docB){if(!isObject(docA)||!hasMarker(docA)||!isObject(docB)||!hasMarker(docB)){throw TypeError("Only objects with the mergeable marker can be merged")}const result=mergeFunction({a:docA,b:docB});return setMergeablePrototype(result)},_mergeFunction:mergeFunction,MERGEABLE_MARKER:MERGEABLE_MARKER};return legibleMergeable}));
